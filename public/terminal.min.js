/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Commands.js":
/*!*************************!*\
  !*** ./src/Commands.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var _Console_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Console.js */ \"./src/Console.js\");\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n\n    modules() {\n        for(let [name, module] of _Console_js__WEBPACK_IMPORTED_MODULE_0__.default.getModules()) {\n            _Console_js__WEBPACK_IMPORTED_MODULE_0__.default.print(name);\n        }  \n    },\n\n    async install([ modulePath ]) {\n        if(modulePath) {\n            const module = await _Console_js__WEBPACK_IMPORTED_MODULE_0__.default.fetchModule(modulePath).catch(err => {\n                _Console_js__WEBPACK_IMPORTED_MODULE_0__.default.print(\"[Error] \" + err.message);\n            })\n            await _Console_js__WEBPACK_IMPORTED_MODULE_0__.default.installModule(module);\n        } else {\n            _Console_js__WEBPACK_IMPORTED_MODULE_0__.default.print(\"Provide a module path.\");\n        }\n    },\n\n    async uninstall([ modulePath ]) {\n        if(modulePath && modulePath != \"\") {\n            await _Console_js__WEBPACK_IMPORTED_MODULE_0__.default.uninstallModule(modulePath);\n        } else {\n            _Console_js__WEBPACK_IMPORTED_MODULE_0__.default.print(\"Provide a module name.\");\n        }\n    },\n\n    clear(args) {\n        const terminal = _Console_js__WEBPACK_IMPORTED_MODULE_0__.default.getTerminal();\n        terminal.clear();\n    },\n\n    help() {\n        _Console_js__WEBPACK_IMPORTED_MODULE_0__.default.print(`\\nCommands: \\n${Object.keys(this).join(\", \")}\\n`);\n    },\n\n    exit(args) {\n        return new Promise((resolve) => {\n            const terminal = _Console_js__WEBPACK_IMPORTED_MODULE_0__.default.getTerminal();\n            terminal.setPrefix(\"\");\n            terminal.disableInput();\n            terminal.clear();\n            _Console_js__WEBPACK_IMPORTED_MODULE_0__.default.print(\"Bye.\");\n\n            terminal.remove();\n\n            setTimeout(() => window.close(), 1000);\n        })\n    }\n\n});\n\n\n//# sourceURL=webpack://terminal/./src/Commands.js?");

/***/ }),

/***/ "./src/Console.js":
/*!************************!*\
  !*** ./src/Console.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => /* binding */ Console\n/* harmony export */ });\n/* harmony import */ var _Commands_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Commands.js */ \"./src/Commands.js\");\n/* harmony import */ var _Terminal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Terminal.js */ \"./src/Terminal.js\");\n\n\n\nconst terminal = new _Terminal_js__WEBPACK_IMPORTED_MODULE_1__.default();\n\nlet modules = new Map();\n\nconst MODULE_REGISTRY_ID = \"modules\";\n\nfunction getModuleRegistry() {\n    let moduleRegistry = localStorage.getItem(MODULE_REGISTRY_ID);\n    if(!moduleRegistry) {\n        moduleRegistry = '{ \"modules\": [] }';\n    }\n    return JSON.parse(moduleRegistry);\n}\n\nfunction saveModuleRegistry(reg) {\n    localStorage.setItem(MODULE_REGISTRY_ID, JSON.stringify(reg));\n}\n\nlet idle = true;\n\nclass Console {\n\n    static get INPUT_PREFIX() {\n        return \"terminal@web:~$ \";\n    }\n    \n    static async loadModules() {\n        const moduleRegistry = getModuleRegistry();\n        for(let modulePath of moduleRegistry.modules) {\n            const module = await Console.fetchModule(modulePath).catch(err => {\n                Console.print(\"[Module Error] Module: '\"+modulePath+\"': \" + err.message);\n            });\n            Console.installModule(module);\n        }\n    }\n\n    static async evaluateInput(args) {\n        function evaluate() {\n            const result = eval(args.join(\" \"));\n            if(result) {\n                Console.print(result.toString());\n            }\n        }\n\n        if(args[0] != \"\") {\n            if(_Commands_js__WEBPACK_IMPORTED_MODULE_0__.default[args[0]]) {\n                idle = false;\n                document.title = args[0];\n                let exit;\n                try {\n                    exit = await _Commands_js__WEBPACK_IMPORTED_MODULE_0__.default[args[0]](args.slice(1));\n                } catch(err) {\n                    document.title = \"Terminal\";\n                    throw new Error(err);\n                }\n                document.title = \"Terminal\";\n                if(exit !== 0 && exit != undefined) {\n                    Console.print(\"\\nProcess exited.\\n\");\n                }\n                terminal.read(this.INPUT_PREFIX);\n                idle = true;\n            } else {\n                try {\n                    evaluate.call(Console);\n                } catch(err) {\n                    console.error(err);\n                    Console.print(\"\\n[Error] \" + err.message);\n                }\n            }\n        }\n    }\n\n    static getModules() {\n        return modules;\n    }\n\n    static async fetchModule(path) {\n        const raw = await fetch(path).then(res => res.text());\n        const base64 = \"data:application/javascript;base64,\" + btoa(raw);\n        const module = await fetchModule(base64);\n        module.origin = path;\n\n        // register module in localstorage\n        let registry = getModuleRegistry();\n        if(registry.modules.indexOf(module.origin) === -1) {\n            registry.modules.push(module.origin);\n        }\n        saveModuleRegistry(registry);\n\n        return module;\n    }\n\n    static async installModule(module) {\n        const name = module.moduleName || module.origin;\n        if(modules.get(name)) {\n            Console.log(`[Module] Module '${name}' already installed.`);\n            return;\n        }\n        try {\n            if(module.install) {\n                modules.set(name, module);\n                await module.install(Console);\n\n                Console.log(`[Module] Installed module '${name}'`);\n    \n                if(module.commandName) {\n                    _Commands_js__WEBPACK_IMPORTED_MODULE_0__.default[module.commandName] = module.run;\n                }\n            } else {\n                throw new Error(`Missing install method in module: ${name}`);\n            }\n        } catch(err) {\n            Console.log(\"[Error] \" + err.message);\n        }\n    }\n\n    static uninstallModule(moduleName) {\n        const module = modules.get(moduleName);\n        if(module) {\n            modules.delete(moduleName);\n            module.uninstall();\n            if(module.commandName) {\n                _Commands_js__WEBPACK_IMPORTED_MODULE_0__.default[module.commandName] = null;\n            }\n\n            // nuregister\n            let moduleRegistry = getModuleRegistry();\n            moduleRegistry.modules.splice(moduleRegistry.modules.indexOf(module.origin), 1);\n            saveModuleRegistry(moduleRegistry);\n\n            Console.print(`[Module] Uninstalled module '${moduleName}'`);\n        } else {\n            Console.print(\"Module not found.\");\n        }\n    }\n    \n    static getTerminal() {\n        return terminal;\n    }\n    \n    static async simulateWrite(str, ms = 24) {\n        return new Promise((resolve) => {\n            terminal.disableInput();\n    \n            const time = ms;\n    \n            let index = 0;\n            const int = setInterval(() => {\n    \n                const curr = str[index];\n    \n                terminal.write(curr);\n    \n                index++;\n    \n                if (index == str.length) {\n                    clearInterval(int);\n                    resolve();\n                }\n            }, time);\n        })\n    }\n    \n    static print(str) {\n        if(typeof str == \"object\") {\n            str = JSON.stringify(str, null, '\\t');\n        }\n        const lines = str.split(\"\\n\");\n        for (let line of lines) {\n            terminal.write(line);\n            terminal.write('\\n');\n        }\n    }\n\n    static async readLine(prefix = \"\") {\n        const value = await terminal.read(prefix);\n        return value;\n    }\n\n    static log(...str) {\n        const ts = `${new Date().toGMTString()}: `;\n        return this.print(str.join(\" \"));\n    }\n    \n    static printHTML(width, height, content) {\n        this.print(`\\\\\\\\\\\\HTML ${width} ${height} ${content}`);\n    }\n    \n    static sleep(time) {\n        return new Promise((resolve) => {\n            setTimeout(() => resolve(), time);\n        })\n    }\n    \n    static clear() {\n        terminal.clear();\n    }\n}\n\n\n//# sourceURL=webpack://terminal/./src/Console.js?");

/***/ }),

/***/ "./src/ConsoleModule.js":
/*!******************************!*\
  !*** ./src/ConsoleModule.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => /* binding */ ConsoleModule\n/* harmony export */ });\nclass ConsoleModule {\n\n    static get moduleName() {\n        return \"console-module\";\n    }\n    \n    static get commandName() {\n        return \"\";\n    }\n\n    static install() {\n        \n    }\n    \n    static uninstall() {\n        \n    }\n\n    static run(args) {\n\n    }\n}\n\nwindow[\"ConsoleModule\"] = ConsoleModule;\n\n\n//# sourceURL=webpack://terminal/./src/ConsoleModule.js?");

/***/ }),

/***/ "./src/FileSystem.js":
/*!***************************!*\
  !*** ./src/FileSystem.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => /* binding */ FileSystem\n/* harmony export */ });\n/* harmony import */ var _Console__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Console */ \"./src/Console.js\");\n\n\nconst fs = {\n    children: [\n        {\n            name: \"File.png\",\n            type: \"file\",\n        },\n        {\n            name: \"Tests\",\n            type: \"directory\",\n            children: [\n                {\n                    name: \"TestFile.jpg\",\n                    type: \"file\",\n                },\n                {\n                    name: \"TestText.txt\",\n                    type: \"file\",\n                },\n                {\n                    name: \"Tests2\",\n                    type: \"directory\",\n                    children: [\n                        {\n                            name: \"TestFile2.jpg\",\n                            type: \"file\",\n                        },\n                        {\n                            name: \"TestText2.txt\",\n                            type: \"file\",\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n};\nlet cd = \"/\";\n\nclass FileSystem {\n\n    static getDirByName(cdir, name) {\n        for(let child of cdir.children) {\n            if(child.type == \"directory\" && child.name == name) {\n                return child;\n            }\n        }\n    }\n\n    static getDirByPath(path) {\n        const findChild = (root, name) => {\n            for(let child of root.children) {\n                if(child.type == \"directory\" && child.name == name) {\n                    return child;\n                }\n            }\n        }\n\n        let curr = fs;\n        let dirpath = path.split(\"/\").filter(p => p != \"\").reverse();\n\n        while(dirpath.length > 0) {\n            curr = findChild(curr, dirpath[dirpath.length-1]);\n            if(!curr) {\n                break;\n            } else {\n                dirpath.pop();\n            }\n        }\n\n        return curr;\n    }\n\n    static changeDir(relatievPath) {\n        let newDir = cd + relatievPath + \"/\";\n        if(relatievPath == \"..\") {\n            newDir = cd.split(\"/\").splice(0, cd.split(\"/\").length - 2).join(\"/\");\n        }\n        const dir = this.getDirByPath(newDir);\n        if(dir) {\n            cd = newDir;\n        } else {\n            _Console__WEBPACK_IMPORTED_MODULE_0__.default.print('Directory not found.');\n        }\n    }\n\n    static get modules() {\n        return [\n            {\n                moduleName: \"ls\",\n                commandName: \"ls\",\n                install() {},\n                run: (arguemnts) => {\n                    _Console__WEBPACK_IMPORTED_MODULE_0__.default.print(\"\");\n                    _Console__WEBPACK_IMPORTED_MODULE_0__.default.print(cd);\n                    _Console__WEBPACK_IMPORTED_MODULE_0__.default.print(\"--------------------------------------\");\n                    for(let child of this.getDirByPath(cd).children) {\n                        _Console__WEBPACK_IMPORTED_MODULE_0__.default.print(`${child.type.padEnd(15, \" \")} ${child.name}`);\n                    }\n                    _Console__WEBPACK_IMPORTED_MODULE_0__.default.print(\"\");\n                }\n            },\n            {\n                moduleName: \"cd\",\n                commandName: \"cd\",\n                install() {},\n                run: (args) => {\n                    if(args[0] != \"\") {\n                        this.changeDir(args[0]);\n                    }\n                    _Console__WEBPACK_IMPORTED_MODULE_0__.default.print(cd);\n                }\n            }\n        ]\n    }\n\n}\n\n//# sourceURL=webpack://terminal/./src/FileSystem.js?");

/***/ }),

/***/ "./src/PostProcessing.js":
/*!*******************************!*\
  !*** ./src/PostProcessing.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createWebgl2Canvas\": () => /* binding */ createWebgl2Canvas\n/* harmony export */ });\nfunction createWebgl2Canvas(canvas, options = {\n    alpha: false,\n}) {\n\n    let lastIamge = null;\n\n    const vertexShaderSource = `#version 300 es\n        in vec4 a_position;\n        in vec2 a_uv;\n        out vec2 v_uv;\n\n        void main() {\n            gl_Position = a_position;\n            v_uv = a_uv;\n        }\n    `;\n\n    const fragmentShaderSource = `#version 300 es\n        precision highp float;\n\n        uniform sampler2D u_texture;\n        uniform vec2 resolution;\n        uniform float time;\n\n        in vec2 v_uv;\n        out vec4 outColor;\n\n        const int samples = 32, LOD = 1, sLOD = 1 << LOD;\n        const float sigma = float(samples) * .25;\n\n        float gaussian(vec2 i) {\n            return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );\n        }\n\n        vec4 blur(sampler2D sp, vec2 U, vec2 scale) {\n            vec4 O = vec4(0);  \n            int s = samples / sLOD;\n            \n            for ( int i = 0; i < s * s; i++ ) {\n                vec2 d = vec2(i % s, i / s) * float(sLOD) - float(samples) / 2.0;\n                O += gaussian(d) * textureLod(sp, U + scale * d , float(LOD));\n            }\n            \n            return O / O.a;\n        }\n        \n        void main() {\n            float ca_scale = 0.5;\n            float bloom_scale = 1.0;\n\n            float r = texture(u_texture, vec2(v_uv.x - (ca_scale / resolution.x), v_uv.y)).r;\n            float g = texture(u_texture, vec2(v_uv.x, v_uv.y - ((ca_scale / resolution.x) * 1.5))).g;\n            float b = texture(u_texture, vec2(v_uv.x, v_uv.y + ((ca_scale / resolution.x) * 2.0) )).b;\n\n            vec4 rgba = vec4(r, g, b, 1.0);\n\n            vec4 rgbaBlured = blur(u_texture, v_uv, bloom_scale / resolution.xy);\n\n            outColor = rgba * 0.9;\n            outColor += rgbaBlured * 0.5;\n\n            if(mod(v_uv.y * resolution.y, 2.0) >= 1.5) {\n                outColor *= 0.69;\n            }\n\n            float v = mod(time * 5.0 - v_uv.y, -1.0);\n            if(v < -0.5 && v > -0.9) {\n                outColor += outColor * 0.05;\n            }\n        }\n    `;\n\n    const gl = canvas.getContext(\"webgl2\", {\n        alpha: false,\n        antialias: true,\n        premultipliedAlpha: false,\n        desynchronized: true,\n        preserveDrawingBuffer: true,\n    });\n\n    function createShader(gl, type, source) {\n        var shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n        if (success) {\n            return shader;\n        }\n\n        console.log(gl.getShaderInfoLog(shader));\n        gl.deleteShader(shader);\n    }\n\n    var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n    var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n\n    function createProgram(gl, vertexShader, fragmentShader) {\n        var program = gl.createProgram();\n        gl.attachShader(program, vertexShader);\n        gl.attachShader(program, fragmentShader);\n        gl.linkProgram(program);\n        var success = gl.getProgramParameter(program, gl.LINK_STATUS);\n        if (success) {\n            return program;\n        }\n\n        console.log(gl.getProgramInfoLog(program));\n        gl.deleteProgram(program);\n    }\n\n    var program = createProgram(gl, vertexShader, fragmentShader);\n\n    const vao = gl.createVertexArray();\n    gl.bindVertexArray(vao);\n\n    // positions\n    const positionAttributeLocation = gl.getAttribLocation(program, \"a_position\");\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n    const positions = [\n        -1, -1,\n        -1, 1,\n        1, 1,\n\n        1, 1,\n        1, -1,\n        -1, -1,\n    ];\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(positionAttributeLocation);\n    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);\n\n\n    // uvs\n    const uvAttributeLocation = gl.getAttribLocation(program, \"a_uv\");\n    const uvBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);\n\n    const uvs = [\n        0, 0,\n        0, -1,\n        1, -1,\n\n        1, -1,\n        1, 0,\n        0, 0,\n    ];\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(uvs), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(uvAttributeLocation);\n    gl.vertexAttribPointer(uvAttributeLocation, 2, gl.FLOAT, false, 0, 0);\n\n    gl.useProgram(program);\n    gl.bindVertexArray(vao);\n\n    // Create a texture.\n    const texture = gl.createTexture();\n\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n\n    const U_resolution = gl.getUniformLocation(program, \"resolution\");\n    const U_time = gl.getUniformLocation(program, \"time\");\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n\n    let width = 0;\n\n    return {\n        draw(image) {\n            lastIamge = image;\n\n            gl.uniform1fv(U_time, [ performance.now() / 1000 ]);\n\n            gl.viewport(0, 0, canvas.width, canvas.height);\n            if(width === image.width) {\n                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);\n            } else {\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, image.width, image.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);\n                width = image.width;\n\n                gl.uniform2fv(U_resolution, [ image.width, image.height ]);\n            }\n            gl.drawArrays(gl.TRIANGLES, 0, positions.length / 2);\n\n            width = image.width;\n        },\n        reformat(width, height) {\n            canvas.width = width;\n            canvas.height = height;\n\n            if(lastIamge) {\n                this.draw(lastIamge);\n            }\n        },\n        get canvas() {\n            return canvas;\n        }\n    };\n}\n\n\n//# sourceURL=webpack://terminal/./src/PostProcessing.js?");

/***/ }),

/***/ "./src/Terminal.js":
/*!*************************!*\
  !*** ./src/Terminal.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => /* binding */ Terminal\n/* harmony export */ });\n/* harmony import */ var _PostProcessing_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PostProcessing.js */ \"./src/PostProcessing.js\");\n\n\nconst BORDER_PADDING = [32, 32];\nconst CURSOR_OFFSET = [1, 0];\nconst FONT_SIZE = 13;\nconst FONT_FAMILY = \"monospace\";\nconst FONT_WEIGHT = 200;\nconst FONT_COLOR = '#eee';\nconst SLECTION_COLOR = '#717171';\nconst SHADOW_BLUR = 0;\nconst CURSOR_HEIGHT = 16;\nconst CURSOR_WIDTH = 6;\nconst VALID_CHARS = ` ~{}@=<>^abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ()[]-.,_:;#+'*/&%$§!?€1234567890\"`;\nconst LINE_PADDING = 3;\n\nlet LINE_WRAPPING = true;\nlet CHAR_WIDTH = 7.69;\nlet CHAR_HEIGHT = 12;\n\nlet canvas, context;\nlet buffer = [\n    \"Terminal Version 1.0\",\n    \"(c) 2020 luckydye. All rights reserved.\",\n    \"\",\n];\nlet hiddenBuffer = [];\nlet cursor = [\n    buffer[buffer.length-1].length, \n    buffer.length - 1\n];\nlet view = [0, 0];\nlet selection = [[0,0], [0,0]];\nlet prefix = \"\";\nlet inputEnabled = true;\nlet hideOutput = false;\nlet history = localStorage.history ? JSON.parse(localStorage.history) : [];\nlet historyCursor = -1;\n\nlet img = new Image();\n\nconst htmlElements = {};\n\nclass SubmitEvent extends Event {\n    constructor(value) {\n        super('submit');\n        this.value = value;\n    }\n}\n\nclass ShortcutEvent extends Event {\n\n    get defaultPrevented() {\n        return this._defaultPrevented;\n    }\n\n    set defaultPrevented(v) {\n        this._defaultPrevented = v;\n    }\n\n    constructor(key) {\n        super('shortcut');\n        this.key = key;\n        this._defaultPrevented = false;\n    }\n}\n\nclass Terminal extends HTMLElement {\n\n    get hideOutput() {\n        return hideOutput;\n    }\n\n    set hideOutput(v) {\n        hideOutput = v;\n    }\n\n    get inputEnabled() {\n        return inputEnabled;\n    }\n\n    set inputEnabled(v) {\n        inputEnabled = v;\n    }\n\n    get prefix() {\n        return prefix;\n    }\n    \n    set prefix(v) {\n        prefix = v;\n    }\n\n    get cursor() {\n        return cursor;\n    }\n\n    focus() {\n        canvas.focus();\n    }\n\n    constructor() {\n        super();\n\n        this.bounds = { x: 0, y: 0 };\n\n        canvas = document.createElement('canvas');\n        canvas.tabIndex = 0;\n        context = canvas.getContext(\"2d\");\n\n        window.addEventListener('resize', e => {\n            this.reformat();\n        })\n\n        window.addEventListener('wheel', e => {\n            const dir = Math.sign(e.deltaY) * 2;\n\n            const cursorY = this.getCursorPosition()[1];\n            const maxY = Math.max(0, cursorY - (canvas.height - (this.lineHeight * 3)));\n\n            view[1] = Math.max(0, Math.min(maxY, view[1] + dir * this.lineHeight));\n        });\n\n        this.addEventListener('keydown', e => {\n            this.handleInput(e);\n        })\n\n\n        // mouse selections\n        let mouseStart = [0, 0];\n\n        const setSelection = (index, px, py) => {\n            const pos = this.pixelToBufferPos(\n                px + view[0], \n                py + view[1]\n            );\n            selection[index][0] = pos[0];\n            selection[index][1] = pos[1];\n        }\n\n        const mouseDown = e => {\n            if(!this.bounds) return;\n\n            let x = e.clientX - this.bounds.x;\n            let y = e.clientY - this.bounds.y;\n\n            if(e.button === 0) {\n                mouseStart[0] = x;\n                mouseStart[1] = y;\n    \n                setSelection(0, x, y);\n                setSelection(1, x, y);\n                window.addEventListener(\"mousemove\", mouseMove); \n            }\n        }\n\n        const mouseUp = e => {\n            if(!this.bounds) return;\n\n            let x = e.clientX - this.bounds.x;\n            let y = e.clientY - this.bounds.y;\n\n            if(e.button === 0) {\n                let index = 1;\n                if(mouseStart[1] > y) {\n                    index = 0;\n                }\n                setSelection(index, x, y);\n                window.removeEventListener(\"mousemove\", mouseMove);\n            }\n        }\n\n        const mouseMove = e => {\n            if(!this.bounds) return;\n            \n            let x = e.clientX - this.bounds.x;\n            let y = e.clientY - this.bounds.y;\n\n            let index = 1;\n            if(mouseStart[1] > y) {\n                index = 0;\n            }\n            setSelection(index, x, y);\n        }\n\n        window.addEventListener(\"mousedown\", mouseDown);\n        window.addEventListener(\"mouseup\", mouseUp);\n\n        this.addEventListener(\"contextmenu\", e => {\n            const txt = this.getSelectionFromBuffer(selection);\n            navigator.clipboard.writeText(txt);\n            this.resetSelection();\n            e.preventDefault();\n        });\n\n        this.attachShadow({ mode: 'open' });\n    }\n    \n    resetSelection() {\n        selection = [[0,0], [0,0]];\n    }\n\n    getSelectionFromBuffer(selection) {\n        let copiedLines = [];\n\n        const startLine = selection[0][1];\n        const lines = selection[1][1] - selection[0][1];\n        const start = selection[0];\n        const end = selection[1];\n\n        for(let line = 0; line <= lines; line++) {\n            let a = line > 0 && lines > 0 ? 0 : start[0];\n            let b = line === lines ? end[0] : undefined;\n\n            const txt = buffer[startLine + line].slice(a, b);\n            copiedLines.push(txt);\n        }\n\n        return copiedLines.join(\"\\n\");\n    }\n\n    pixelToBufferPos(x, y) {\n        return [\n            Math.floor((x - BORDER_PADDING[0]) / CHAR_WIDTH), \n            Math.floor((y - BORDER_PADDING[1]) / this.lineHeight)\n        ]\n    }\n\n    getContext() {\n        return context;\n    }\n\n    init() {\n        const style = document.createElement('style');\n        style.innerHTML = `\n            :host {\n                width: 100%;\n                height: 100%;\n                overflow: hidden;\n            }\n            :host(:focus) {\n                z-index: 1000000;\n                opacity: 1;\n                pointer-events: all;\n            }\n            canvas {\n                filter: contrast(1.1) blur(.33px);\n                outline: none;\n            }\n            .inline-element {\n                position: absolute;\n                top: calc(var(--elementY) * 1px - var(--scrollY) * 1px);\n                left: calc(var(--elementX) * 1px);\n                height: calc(var(--elementHeight) * 1px);\n                width: calc(var(--elementWidth) * 1px);\n                display: block;\n                overflow: hidden;\n                color: #eee;\n                font-family: monospace;\n                user-select: none;\n            }\n            .inline-element + * {\n                display: inline;\n            }\n        `;\n        this.shadowRoot.appendChild(style);\n\n        const postCanvas = document.createElement('canvas');\n        postCanvas.width = 1280;\n        postCanvas.height = 720;\n        this.postCavnas = (0,_PostProcessing_js__WEBPACK_IMPORTED_MODULE_0__.createWebgl2Canvas)(postCanvas);\n        this.postCavnas.reformat(this.clientWidth, this.clientHeight);\n\n        this.postCavnas.canvas.tabIndex = 0;\n\n        this.shadowRoot.appendChild(this.postCavnas.canvas);\n    \n        this.loop();\n    }\n\n    connectedCallback() {\n        if(!canvas.parentNode) {\n            this.init();\n        }\n        this.reformat();\n    }\n\n    append(index, line) {\n        const temp = buffer.slice(0, index);\n        temp.push(line);\n        temp.push(...buffer.slice(index));\n\n        if(cursor[1] >= index) {\n            cursor[1]++;\n        }\n\n        this.setBuffer(temp);\n    }\n\n    setBuffer(newBuffer) {\n        buffer = newBuffer;\n    }\n\n    clear() {\n        buffer = [\"\"];\n        for(let ele in htmlElements) {\n            htmlElements[ele].remove();\n        }\n        this.setCursor(0, 0);\n    }\n\n    setCursor(x, y) {\n        cursor[0] = x != null ? x : cursor[0];\n        cursor[1] = y != null ? y : cursor[1];\n    }\n\n    setPrefix(str = \"\") {\n        this.prefix = str;\n    }\n\n    disableInput() {\n        this.inputEnabled = false;\n    }\n\n    enableInput() {\n        this.inputEnabled = true;\n    }\n\n    disableLineWrapping() {\n        LINE_WRAPPING = false;\n    }\n\n    enableLineWrapping() {\n        LINE_WRAPPING = true;\n    }\n\n    handleSubmit(line) {\n        if(hideOutput) {\n            line = hiddenBuffer.join(\"\");\n            hideOutput = false;\n        } else {\n            line = line.slice(this.prefix.length);\n        }\n        this.pushToHistory(line);\n        this.dispatchEvent(new SubmitEvent(line));\n    }\n\n    pushToHistory(input) {\n        if(input == history[0]) {\n            return;\n        }\n        if(input != \"\") {\n            history.unshift(input);\n        }\n        historyCursor = -1;\n        localStorage.history = JSON.stringify(history);\n    }\n\n    cancelInput() {\n        buffer[cursor[1]] = this.prefix;\n        this.setCursor(buffer[cursor[1]].length);\n    }\n\n    replaceInput(str) {\n        this.cancelInput();\n        this.write(str);\n    }\n\n    read(newPrefix) {\n        return new Promise((resolve) => {\n            const currLine = buffer[buffer.length-1];\n            this.inputEnabled = true;\n            this.prefix = newPrefix || currLine;\n            if(newPrefix && currLine !== newPrefix) {\n                this.write(newPrefix);\n            }\n\n            const submitCallback = e => {\n                resolve(e.value);\n                this.removeEventListener('submit', submitCallback);\n            }\n            this.addEventListener('submit', submitCallback);\n        })\n    }\n\n    newline() {\n        const newLine = \"\";\n        const currLine = buffer[buffer.length-1];\n        buffer.push(newLine);\n        cursor[0] = newLine.length;\n        cursor[1]++;\n        return currLine;\n    }\n\n    write(str) {\n        switch(str) {\n            case \"\\0\":\n                    // nothing (sleep)\n                break;\n            case \"\\r\":\n                    const currLine = this.newline();\n                    this.handleSubmit(currLine);\n                break;\n            case \"\\n\":\n                    this.newline();\n                break;\n            default:\n                const temp = buffer[cursor[1]].split(\"\").slice(0, cursor[0]);\n\n                if(hideOutput) {\n                    hiddenBuffer.push(str);\n                    temp.push(...(new Array(str.length).fill(\"*\")));\n                } else {\n                    temp.push(str);\n                }\n        \n                const tail = buffer[cursor[1]].split(\"\").slice(cursor[0]);\n                temp.push(...tail);\n                buffer[cursor[1]] = temp.join(\"\");\n                cursor[0] += str.length;\n        }\n\n        const cursorY = this.getCursorPosition()[1];\n        view[1] = Math.max(0, cursorY - (canvas.height - (this.lineHeight * 3)));\n    }\n\n    handleInput(e) {\n        let key = e.key;\n        const shift = e.shiftKey;\n        const ctrl = e.ctrlKey;\n\n        if(inputEnabled) {\n            if(key == \"Enter\") {\n                this.write('\\r');\n            }\n            if(key == \"ArrowUp\") {\n                historyCursor = Math.min(historyCursor + 1, history.length-1);\n                if(history[historyCursor]) {\n                    this.replaceInput(history[historyCursor]);\n                }\n            }\n            if(key == \"ArrowDown\") {\n                historyCursor = Math.max(historyCursor - 1, 0);\n                if(history[historyCursor]) {\n                    this.replaceInput(history[historyCursor]);\n                }\n            }\n            if(key == \"ArrowLeft\") {\n                cursor[0] = Math.max(cursor[0]-1, Math.max(prefix.length, 0));\n            }\n            if(key == \"ArrowRight\") {\n                cursor[0] = Math.min(cursor[0]+1, buffer[buffer.length-1].length);\n            }\n            if(key == \"Escape\") {\n                this.cancelInput();\n            }\n            if(key == \"End\") {\n                cursor[0] = buffer[buffer.length-1].length;\n            }\n            if(key == \"Home\") {\n                cursor[0] = Math.max(prefix.length, 0);\n            }\n            if(key == \"Backspace\") {\n                if(cursor[0] > 0 && cursor[0] > prefix.length) {\n                    const temp = buffer[buffer.length-1].split(\"\").slice(0, cursor[0]-1);\n                    const tail = buffer[buffer.length-1].split(\"\").slice(cursor[0]);\n                    temp.push(...tail);\n                    buffer[buffer.length-1] = temp.join(\"\");\n                    cursor[0]--;\n                }\n            }\n            if(key == \"Delete\") {\n                const temp = buffer[buffer.length-1].split(\"\").slice(0, cursor[0]);\n                const tail = buffer[buffer.length-1].split(\"\").slice(cursor[0]+1);\n                temp.push(...tail);\n                buffer[buffer.length-1] = temp.join(\"\");\n            }\n    \n            if(VALID_CHARS.indexOf(key) != -1 && !ctrl) {\n                this.write(key);\n            }\n        }\n\n        if(ctrl) {\n            const ev = new ShortcutEvent(key);\n            const canceled = this.dispatchEvent(ev);\n\n            e.preventDefault();\n            e.stopPropagation();\n\n            if(!ev.defaultPrevented) {\n                if(VALID_CHARS.indexOf(key) != -1) {\n                    this.dispatchEvent(new SubmitEvent(\"^\" + key));\n                }\n            }\n        }\n\n        e.preventDefault();\n        e.stopPropagation();\n    }\n\n    reformat() {\n        canvas.width = this.clientWidth;\n        canvas.height = this.clientHeight;\n\n        this.postCavnas.reformat(canvas.width, canvas.height);\n\n        const cursorY = this.getCursorPosition()[1];\n        view[1] = Math.max(0, cursorY - (canvas.height - (this.lineHeight * 3)));\n\n        this.bounds = this.getClientRects()[0];\n    }\n\n    draw(context) {\n        context.globalCompositeOperation = \"normal\";\n        context.fillStyle = \"#0c0c0c\";\n        context.fillRect(0, 0, context.canvas.width, context.canvas.height);\n\n        if(canvas.width <= 0) return;\n\n        context.font = `${FONT_WEIGHT} ${FONT_SIZE}px ${FONT_FAMILY}`;\n        context.textAlign = 'left';\n        context.textBaseline = 'top';\n        \n        const text = context.measureText(\"M\");\n        CHAR_WIDTH = text.width;\n\n        context.shadowColor = FONT_COLOR;\n        context.shadowBlur = SHADOW_BLUR;\n        \n        context.fillStyle = FONT_COLOR;\n\n        this.drawBuffer();\n\n        if(this.inputEnabled) {\n            this.drawCursor();\n        }\n        this.drawSelection();\n\n        context.shadowColor = \"none\";\n        context.shadowBlur = 0;\n\n        this.style.setProperty('--scrollY', view[1]);\n\n        img = context.getImageData(0, 0, canvas.width, canvas.height);\n        this.postCavnas.draw(img);\n    }\n\n    drawCursor() {\n        const ts = Date.now() / 500;\n\n        if(ts % 2 > 1) {\n            const pos = this.getCursorPosition();\n\n            context.fillStyle = FONT_COLOR;\n            context.fillRect(pos[0], pos[1] - view[1], CURSOR_WIDTH, CURSOR_HEIGHT);\n        }\n    }\n\n    bufferToPixelPos(x, y) {\n        return [\n            x * CHAR_WIDTH + BORDER_PADDING[0] - view[0],\n            y * this.lineHeight + BORDER_PADDING[1] - view[1]\n        ]\n    }\n\n    drawSelection() {\n        const start = this.bufferToPixelPos(...selection[0]);\n        const end = this.bufferToPixelPos(...selection[1]);\n\n        context.globalCompositeOperation = \"screen\";\n        context.shadowColor = \"\";\n        context.shadowBlur = 0;\n\n        const lines = selection[1][1] - selection[0][1];\n        \n        for(let i = 0; i <= lines; i++) {\n            let x = 0;\n            const y = start[1] + (this.lineHeight * i);\n\n            let width = CHAR_WIDTH;\n\n            const xDiff = end[0] - start[0];\n\n            if(lines === i) {\n                width = xDiff + start[0];\n            } else {\n                width = canvas.width;\n            }\n\n            if(i === 0) {\n                x = start[0];\n\n                if(lines === i) {\n                    width = xDiff;\n                }\n            }\n\n            context.fillStyle = SLECTION_COLOR;\n            context.fillRect(x, y, width, this.lineHeight);\n        }\n\n        context.globalCompositeOperation = \"\";\n    }\n\n    getMaxBufferWidth() {\n        return canvas.width - (BORDER_PADDING[0] * 2);\n    }\n\n    get lineHeight() {\n        return CHAR_HEIGHT + LINE_PADDING;\n    }\n\n    getCursorPosition() {\n        const max_line_px_length = this.getMaxBufferWidth();\n\n        let posY = 0;\n        for(let i = 0; i < cursor[1]; i++) {\n            const line = buffer[i];\n\n            const html = this.parseHTMLLine(line);\n            if(html) {\n                posY += html.height / this.lineHeight;\n            } else {\n                const text = context.measureText(line);\n                if(max_line_px_length - text.width < 0 && LINE_WRAPPING) {\n                    const parts = sliceLine(line, max_line_px_length / CHAR_WIDTH);\n                    for(let part of parts) {\n                        posY++;\n                    }\n                } else {\n                    posY++;\n                }\n            }\n        }\n\n        const x = BORDER_PADDING[0] + (cursor[0] * CHAR_WIDTH);\n        const y = BORDER_PADDING[1] + (posY * CHAR_HEIGHT) + (posY * LINE_PADDING) + (CHAR_HEIGHT / 2) - (CURSOR_HEIGHT / 2);\n\n        return [x + CURSOR_OFFSET[0], y + CURSOR_OFFSET[1]];\n    }\n\n    parseHTMLLine(line) {\n        if(line.slice(0, 7) == \"\\\\\\\\\\\\HTML\") {\n            const htmlMeta = line.slice(7).split(\" \").slice(0, 3).join(\" \");\n            const [ nul, width, height ] = htmlMeta.split(\" \").map(v => +v);\n\n            return {\n                content: line.slice(7 + htmlMeta.length),\n                width, \n                height: Math.round(height / this.lineHeight) * this.lineHeight\n            }\n        }\n    }\n\n    drawBuffer() {\n        const max_line_px_length = this.getMaxBufferWidth();\n\n        let x = BORDER_PADDING[0];\n        let y = BORDER_PADDING[1] - view[1];\n\n        const drawLine = (line, index) => {\n            context.fillText(line, x, y);\n            y += CHAR_HEIGHT + LINE_PADDING;\n        }\n\n        let index = -1;\n        for(let line of buffer) {\n            index++;\n\n            const html = this.parseHTMLLine(line);\n            if(html) {\n                if(!htmlElements[index]) {\n                    htmlElements[index] = document.createElement('div');\n                    const ele = htmlElements[index];\n                    ele.className = \"inline-element\";\n                    ele.style.setProperty('--elementY', y + view[1]);\n                    ele.style.setProperty('--elementX', x);\n                    ele.style.setProperty('--elementWidth', html.width);\n                    ele.style.setProperty('--elementHeight', html.height);\n                    ele.innerHTML = html.content || \"\";\n                    this.shadowRoot.appendChild(ele);\n                }\n                y += html.height;\n            } else {\n                const text = context.measureText(line);\n                if(max_line_px_length - text.width < 0 && LINE_WRAPPING) {\n                    const parts = sliceLine(line, max_line_px_length / CHAR_WIDTH);\n                    for(let part of parts) {\n                        drawLine(part);\n                    }\n                } else {\n                    drawLine(line);\n                }\n            }\n        }\n    }\n\n    loop() {\n        this.draw(context);\n        setTimeout(this.loop.bind(this), 1000 / 60);\n    }\n\n}\n\nfunction sliceLine(line, maxLength) {\n    if(maxLength < 0) {\n        return [];\n    }\n\n    const parts = [];\n\n    line = line.split(\"\");\n\n    while(line.length > maxLength) {\n        const temp = line.splice(0, maxLength);\n        parts.push(temp.join(\"\"));\n    }\n    parts.push(line.join(\"\"));\n\n    return parts;\n}\n\ncustomElements.define('gyro-terminal', Terminal);\n\n\n//# sourceURL=webpack://terminal/./src/Terminal.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ConsoleModule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ConsoleModule.js */ \"./src/ConsoleModule.js\");\n/* harmony import */ var _Console_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Console.js */ \"./src/Console.js\");\n/* harmony import */ var _FileSystem_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FileSystem.js */ \"./src/FileSystem.js\");\n/* harmony import */ var _modules_ws_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/ws.js */ \"./src/modules/ws.js\");\n/* harmony import */ var _modules_title_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/title.js */ \"./src/modules/title.js\");\n/* harmony import */ var _modules_echo_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/echo.js */ \"./src/modules/echo.js\");\n/* harmony import */ var _modules_html_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/html.js */ \"./src/modules/html.js\");\n\n\n\n\n\n\n\n\nasync function startSequence() {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            _Console_js__WEBPACK_IMPORTED_MODULE_1__.default.clear();\n            _Console_js__WEBPACK_IMPORTED_MODULE_1__.default.print(\"Booting up .\");\n        }, 1000 * 1);\n        setTimeout(() => {\n            _Console_js__WEBPACK_IMPORTED_MODULE_1__.default.clear();\n            _Console_js__WEBPACK_IMPORTED_MODULE_1__.default.print(\"Booting up ..\");\n        }, 1000 * 2);\n        setTimeout(() => {\n            _Console_js__WEBPACK_IMPORTED_MODULE_1__.default.clear();\n            _Console_js__WEBPACK_IMPORTED_MODULE_1__.default.print(\"Booting up ...\");\n        }, 1000 * 3);\n        setTimeout(() => {\n            _Console_js__WEBPACK_IMPORTED_MODULE_1__.default.clear();\n            _Console_js__WEBPACK_IMPORTED_MODULE_1__.default.print(\"Booting up .\");\n        }, 1000 * 4);\n        setTimeout(() => {\n            _Console_js__WEBPACK_IMPORTED_MODULE_1__.default.clear();\n            _Console_js__WEBPACK_IMPORTED_MODULE_1__.default.print(\"Booting up ..\");\n        }, 1000 * 5);\n        setTimeout(() => {\n            _Console_js__WEBPACK_IMPORTED_MODULE_1__.default.clear();\n            resolve();\n        }, 1000 * 6);\n    })\n}\n\nasync function sleep(seconds = 1) {\n    return new Promise((resolve) => {\n        setTimeout(() => resolve(), 1000 * seconds);\n    })\n}\n\nasync function initTerminal() {\n    \n    const nativeModules = [\n        _modules_ws_js__WEBPACK_IMPORTED_MODULE_3__.default,\n        _modules_title_js__WEBPACK_IMPORTED_MODULE_4__.default,\n        _modules_echo_js__WEBPACK_IMPORTED_MODULE_5__.default,\n        _modules_html_js__WEBPACK_IMPORTED_MODULE_6__.default,\n        ..._FileSystem_js__WEBPACK_IMPORTED_MODULE_2__.default.modules,\n    ]\n\n    const terminal = _Console_js__WEBPACK_IMPORTED_MODULE_1__.default.getTerminal();\n    terminal.clear();\n    terminal.disableInput();\n\n    setTimeout(async () => {\n        const terminal = _Console_js__WEBPACK_IMPORTED_MODULE_1__.default.getTerminal();\n        \n        await startSequence();\n        \n        await _Console_js__WEBPACK_IMPORTED_MODULE_1__.default.simulateWrite(\"Initializing\\n\\n\");\n        await sleep();\n\n        await _Console_js__WEBPACK_IMPORTED_MODULE_1__.default.log(\"Loading modules\\n\");\n        await sleep(0.5);\n        for(let modulePath of nativeModules) {\n            let module = modulePath;\n            if(typeof module === \"string\") {\n                module = await _Console_js__WEBPACK_IMPORTED_MODULE_1__.default.fetchModule(modulePath).catch(err => {\n                    _Console_js__WEBPACK_IMPORTED_MODULE_1__.default.log(\"[Error] \" + err.message);\n                })\n            }\n            await _Console_js__WEBPACK_IMPORTED_MODULE_1__.default.installModule(module);\n            await sleep(0.05);\n        }\n\n        await _Console_js__WEBPACK_IMPORTED_MODULE_1__.default.loadModules();\n        _Console_js__WEBPACK_IMPORTED_MODULE_1__.default.print(\"\");\n\n        terminal.addEventListener('shortcut', e => {\n            if(e.key == \"r\") {\n                location.reload();\n            } else if(e.key == \"v\") {\n                navigator.clipboard.readText().then(txt => {\n                    terminal.write(txt);\n                })\n                e.defaultPrevented = true;\n            }\n        });\n\n        while(true) {\n            const value = await terminal.read(_Console_js__WEBPACK_IMPORTED_MODULE_1__.default.INPUT_PREFIX);\n            const args = value.split(\" \");\n            await _Console_js__WEBPACK_IMPORTED_MODULE_1__.default.evaluateInput(args).catch(err => {\n                console.error(err);\n                _Console_js__WEBPACK_IMPORTED_MODULE_1__.default.print(`\\n[Internal Error]: ${err.message}\\n`);\n            });\n        }\n\n    }, 50);\n\n    return _Console_js__WEBPACK_IMPORTED_MODULE_1__.default;\n}\n\nwindow.createTerminal = async () => {\n    return await initTerminal();\n}\n\n\n//# sourceURL=webpack://terminal/./src/main.js?");

/***/ }),

/***/ "./src/modules/echo.js":
/*!*****************************!*\
  !*** ./src/modules/echo.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var _Console__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Console */ \"./src/Console.js\");\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    moduleName: \"echo\",\n    commandName: \"echo\",\n    install() {},\n    run(arguemnts) {\n        _Console__WEBPACK_IMPORTED_MODULE_0__.default.print(arguemnts.join(\" \"));\n    }\n});\n\n//# sourceURL=webpack://terminal/./src/modules/echo.js?");

/***/ }),

/***/ "./src/modules/html.js":
/*!*****************************!*\
  !*** ./src/modules/html.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var _Console__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Console */ \"./src/Console.js\");\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    moduleName: \"html\",\n    commandName: \"html\",\n    install() {},\n    run(arguemnts) {\n        _Console__WEBPACK_IMPORTED_MODULE_0__.default.printHTML(arguemnts[0], arguemnts[1], arguemnts.slice(2).join(\" \"));\n    }\n});\n\n\n//# sourceURL=webpack://terminal/./src/modules/html.js?");

/***/ }),

/***/ "./src/modules/title.js":
/*!******************************!*\
  !*** ./src/modules/title.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    moduleName: \"title\",\n    commandName: \"title\",\n    install() {},\n    run(arguemnts) {\n        const newTitle = arguemnts.join(\" \");\n        document.title = newTitle;\n    }\n});\n\n//# sourceURL=webpack://terminal/./src/modules/title.js?");

/***/ }),

/***/ "./src/modules/ws.js":
/*!***************************!*\
  !*** ./src/modules/ws.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => /* binding */ WebsocketModule\n/* harmony export */ });\nlet Console;\n\nasync function connectToWebSocket(host) {\n    return new Promise((resolve, reject) => {\n        const ws = new WebSocket(host, \"terminal-protocol\");\n\n        ws.onopen = (event) => {\n            resolve(ws);\n        };\n\n        ws.onerror = (event) => {\n            reject(event);\n        };\n    })\n}\n\nclass WebsocketModule extends ConsoleModule {\n    \n    static get moduleName() {\n        return \"ws-module\";\n    }\n\n    static get commandName() {\n        return \"ws\";\n    }\n    \n    static install(cnsl) {\n        Console = cnsl;\n    }\n\n    static uninstall() {\n        \n    }\n\n    static _handleSocketMessage(ws, msg) {\n        const terminal = Console.getTerminal();\n        const data = JSON.parse(msg.data);\n        \n        if(data.type == \"message\") {\n            const str = `${data.data.username}: ${data.data.text}`;\n            terminal.append(terminal.cursor[1], str);\n        }\n        \n        if(data.type == \"left\") {\n            const str = `${data.data.username} left the room.`;\n            terminal.append(terminal.cursor[1], str);\n        }\n    }\n    \n    static async run(args) {\n        const arg1 = args[0].split(\"@\");\n        const login = arg1[0];\n        const address = arg1[1];\n\n        if(address == \"\" || !address) {\n            Console.print(\"Missing address to connect to.\");\n            return;\n        }\n\n        const terminal = Console.getTerminal();\n        terminal.setPrefix(\"\");\n        terminal.disableInput();\n        Console.print(`Connecting to ${args[0]}`);\n\n        let url = `wss:${address}`;\n        // if(location.origin.match('localhost:3000')) {\n        //     url = location.origin.replace(\"https\", \"wss\").replace(\"http\", \"ws\");\n        // }\n\n        return connectToWebSocket(url).then(async ws => {\n            WebsocketModule.prefix = args[0] + \":$ \";\n\n            ws.onmessage = msg => {\n                this._handleSocketMessage(ws, msg);\n            };\n    \n            Console.print('Connected.');\n            Console.print('');\n    \n            while(true) {\n                const input = await terminal.read(WebsocketModule.prefix);\n                if(input == \"\") continue;\n    \n                ws.send(JSON.stringify({\n                    type: 'input',\n                    data: {\n                        input,\n                    }\n                }));\n    \n                if(input.toLocaleLowerCase() == \"^c\") {\n                    return 1;\n                    break;\n                }\n            }\n        }).catch(err => {\n            console.error(err);\n            Console.print(`Error connecting to ${args[0]}`);\n        })\n    }\n\n}\n\nWebsocketModule.prefix = \"> \";\n\n//# sourceURL=webpack://terminal/./src/modules/ws.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/main.js");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;